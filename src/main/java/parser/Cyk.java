package parser;

import language.Grammar;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class Cyk implements Parser {
    private Grammar grammar; //final?

    public Cyk(Grammar grammar) {
        this.grammar = grammar;
    }

    /**
     * {@inheritDoc}
     * @param grammar a context-free grammar (in Chomsky normal form)
     * @param phrase a string representing a phrase
     * @return
     */
    @Override
    public boolean belongsToLanguage(Grammar grammar, String phrase) {
        String[][][] T;

        //prepare the word-array
        String[] words = phrase.split(" ");

        Set<String> parents = grammar.getAllParents();
        Set<List<String>> children = grammar.getAllChildren();

        int n = words.length;
        int m = parents.size() + children.size() + 1;

        //initialise the table
        T = new String[2*n+1][2*n+1][m+1];

        //fill the bottommost row first with the words and simple rules
        T = fillFirstRow(T, n, m, children, words);

        //continuing to the other rows of the table
        T = fillRest(T, n, m, children);

        //deciding whether the sentence belongs to the language generated by the grammar
        boolean belongs = topRulesIncludeStartingSymbol(T, n,m+1, parents, children);

        return belongs;
    }

    /**
     * Fill in the first row of the CYK-table. The first row consists of only the individual words of the phrase and the symbols resulting directly to them.
     * @param T the cyk table
     * @param length length of the array of words
     * @param maxDepth maximum depth of a page, determined by the maximum amount of symbols in the grammar
     * @param children all symbols in the grammar with at least one parent
     * @param words array of the individual words in the phrase
     */
    public String[][][] fillFirstRow(String[][][] T, int length, int maxDepth, Set<List<String>> children, String[] words) {
        //initial values: words as one row in the table
        for (int i = 0; i < length; i++) T[i][i][0] = words[i];

        //direct rules (parents to children with only 1 element)
        for (int i = 0; i < length; i++) {
            for (int depth = 0; depth < maxDepth; depth++) {
                //fetch the content of a cell
                if(T[i][i][depth] == null) continue;

                List<String> possibleRule = new ArrayList<>();
                possibleRule.add(T[i][i][depth]);

                //compare the cell content with every rule (could be optimised by only comparing to the ones with only one element)
                search(T, possibleRule, children, i, i);
            }
        }

        return T;
    }

    /**
     * Fill in the rest of the CYK-table. Starting from the row nearest to an already filled one
     * (starting from {@link #fillFirstRow(String[][][], int, int, Set, String[]) fillFirstRow}).
     *
     * Cell by cell, the method forms possible rules from two already filled in cells covering a substring of a given {@code length}.
     *
     * Next, it compares the possible rules to all existing child-rules in the grammar. All rules will be covered, since
     * there could be many possible individual rule combinations but only one existing parse tree.
     *
     * If a matching rule is found, it is filled in to the next empty page corresponding to the cell.
     * This continues until the whole table is filled with rules.
     *
     * @param T the cyk table
     * @param length length of the array of words
     * @param maxDepth maximum depth of a page, determined by the maximum amount of symbols in the grammar
     * @param children all symbols in the grammar with at least one parent
     */
    public String[][][] fillRest(String[][][] T, int length, int maxDepth, Set<List<String>> children) {
        for (int len = 1; len < length; len++) {
            for (int i = 0; i < length; i++) {
                for (int j = 0; j < length; j++) {
                    //2 page counters (=max elements per rule right now)
                    for (int page1 = 0; page1 < maxDepth; page1++) {
                        for (int page2 = 0; page2 < maxDepth; page2++) {
                            //fetch the contents of the cells
                            List<String> possibleRule = new ArrayList<>();
                            if (T[i][i + j][page1] != null && T[i + j + 1][i + len][page2] != null) {
                                possibleRule.add(T[i][i + j][page1]);
                                possibleRule.add(T[i + j + 1][i + len][page2]);
                            } else continue;

                            //compare the cell content with every rule (could be optimised by only comparing to the ones with only two elements)
                            T = search(T, possibleRule, children, i, i+len);
                        }
                    }
                }
            }
        }

        return T;
    }

    /**
     * Search the grammar for all child-rules matching to the possible rule. Fill the matching rules in to the cell corresponding to the given parameters.
     * @param T the cyk table
     * @param possibleRule a possible rule to be matched
     * @param children all symbols in the grammar with at least one parent
     * @param row row number
     * @param column column number
     */
    public String[][][] search(String[][][] T, List<String> possibleRule, Set<List<String>> children, int row, int column) {
        for (List<String> rule : children) {
            if (rule.equals(possibleRule)) {
                //if found a matching rule, add it's parents to the next empty page corresponding to the cell
                for (String parent : grammar.getParentsByChild(rule)) {
                    T[row][column][nextEmpty(T, row, column)] = parent;
                }
            }
        }
        return T;
    }

    /**
     * Checks whether any pages in the table's last filled cell(i,j) includes the starting symbol.
     * The symbol has at least one child but no parents.
     * @param T the cyk table
     * @param length length of the array of words
     * @param maxDepth maximum amount of pages per cell
     * @param parents all symbols in the grammar with at least one child
     * @param children all symbols in the grammar with at least one parent
     * @return true if at least one of the pages includes a starting symbol, false otherwise
     */
    public boolean topRulesIncludeStartingSymbol(String[][][] T, int length, int maxDepth, Set<String> parents, Set<List<String>> children) {
        boolean found = false;
        for (int i = 0; i < maxDepth; i++) {
            String possibleStartingSymbol = T[0][length-1][i];
            List<String> possibleStartingSymbolChild = new ArrayList<>();
            possibleStartingSymbolChild.add(possibleStartingSymbol);

            if (parents.contains(possibleStartingSymbol) && !children.contains(possibleStartingSymbolChild)) {
                found = true;
            }
        }
        return found;
    }

    /**
     * Finds the next empty page of a cell(i,j) in the 3-dimensional table T
     * @param T the cyk table
     * @param row row number
     * @param column column number
     * @return the index of the next empty page of cell(i,j)
     */
    public static int nextEmpty(String[][][] T,  int row, int column) {
        int maxDepth = T[row][column].length-1;

        for (int depth = 0; depth < maxDepth; depth++) {
            if (T[row][column][depth] == null) return depth;
        }
        return maxDepth;
    }
}
