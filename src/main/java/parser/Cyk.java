package parser;

import basicdatastructures.List;
import language.Grammar;

/**
 * This class uses the CYK-algorithm to decide whether a given phrase belongs to a language generated
 * by the given context-free grammar. The grammar needs to be in the Chomsky normal form.
 */
public class Cyk implements Parser {
    private Grammar grammar;

    public Cyk() {
    }

    public Cyk(final Grammar grammar) {
        this.grammar = grammar;
    }

    public void setGrammar(Grammar grammar) {
        this.grammar = grammar;
    }

    @Override
    public String getName() {
        return "CYK";
    }

    /**
     * {@inheritDoc}
     *
     * @param grammar a context-free grammar (in Chomsky normal form)
     * @param phrase  a string representing a phrase
     * @return
     */
    @Override
    public boolean belongsToLanguage(Grammar grammar, final String[] phrase) {
        //prepare the word-array
        String[][][] t;

        List<String> parents = grammar.getAllParents();
        List<List<String>> children = grammar.getAllChildren();

        int n = phrase.length;
        int m = parents.size() + children.size() + 1;

        //initialise the table
        t = new String[2 * n + 1][2 * n + 1][m + 1];

        //fill the bottommost row first with the words and simple rules
        t = fillFirstRow(t, n, m, children, phrase);

        //continuing to the other rows of the table
        t = fillRest(t, n, m, children);

        //deciding whether the sentence belongs to the language generated by the grammar
        boolean belongs = topRulesIncludeStartingSymbol(t, n, m, parents, children);

        return belongs;
    }

    /**
     * {@inheritDoc}
     *
     * @param phrase  a string representing a phrase
     * @return
     */
    @Override
    public boolean belongsToLanguage(final String[] phrase) {
        return belongsToLanguage(grammar, phrase);
    }

    /**
     * Fill in the first row of the CYK-table. the first row consists of only the individual words of the phrase and the symbols resulting directly to them.
     *
     * @param t        the cyk table
     * @param length   length of the array of words
     * @param maxDepth maximum depth of a page, determined by the maximum amount of symbols in the grammar
     * @param children all symbols in the grammar with at least one parent
     * @param phrase    array of the individual words in the phrase
     */
    public String[][][] fillFirstRow(String[][][] t, int length, int maxDepth, List<List<String>> children, String[] phrase) {
        //initial values: words as one row in the table
        for (int i = 0; i < length; i++) {
            t[i][i][0] = phrase[i];
        }

        //direct rules (parents to children with only 1 element)
        for (int i = 0; i < length; i++) {
            for (int depth = 0; depth < maxDepth; depth++) {
                //fetch the content of a cell
                if (t[i][i][depth] == null) {
                    continue;
                }

                List<String> possibleRule = new List();
                possibleRule.add(t[i][i][depth]);

                //compare the cell content with every rule (could be optimised by only comparing to the ones with only one element)
                search(t, possibleRule, children, i, i);
            }
        }

        return t;
    }

    /**
     * Fill in the rest of the CYK-table. Starting from the row nearest to an already filled one
     * (starting from {@link #fillFirstRow(String[][][], int, int, List, String[]) fillFirstRow}).
     * <p>
     * Cell by cell, the method forms possible rules from two already filled in cells covering a substring of a given {@code length}.
     * <p>
     * Next, it compares the possible rules to all existing child-rules in the grammar. All rules will be covered, since
     * there could be many possible individual rule combinations but only one existing parse tree.
     * <p>
     * If a matching rule is found, it is filled in to the next empty page corresponding to the cell.
     * This continues until the whole table is filled with rules.
     *
     * @param t        the cyk table
     * @param length   length of the array of words
     * @param maxDepth maximum depth of a page, determined by the maximum amount of symbols in the grammar
     * @param children all symbols in the grammar with at least one parent
     */
    public String[][][] fillRest(String[][][] t, int length, int maxDepth, List<List<String>> children) {
        for (int len = 1; len < length; len++) {
            for (int i = 0; i < length; i++) {
                for (int j = 0; j < length; j++) {
                    //2 page counters (=max elements per rule right now)
                    for (int page1 = 0; page1 < maxDepth; page1++) {
                        for (int page2 = 0; page2 < maxDepth; page2++) {
                            //fetch the contents of the cells
                            List<String> possibleRule = new List();
                            if (t[i][i + j][page1] != null && t[i + j + 1][i + len][page2] != null) {
                                possibleRule.add(t[i][i + j][page1]);
                                possibleRule.add(t[i + j + 1][i + len][page2]);

                                //compare the cell content with every rule (could be optimised by only comparing to the ones with only two elements)
                                t = search(t, possibleRule, children, i, i + len);
                            }
                        }
                    }
                }
            }
        }

        return t;
    }

    /**
     * Search the grammar for all child-rules matching to the possible rule. Fill the matching rules in to the cell corresponding to the given parameters.
     *
     * @param t            the cyk table
     * @param possibleRule a possible rule to be matched
     * @param children     all symbols in the grammar with at least one parent
     * @param row          row number
     * @param column       column number
     */
    public String[][][] search(String[][][] t, List<String> possibleRule, List<List<String>> children, int row, int column) {
        for (int i = 0; i < children.size(); i++) {
            List<String> rule = children.get(i);
            if (rule.equals(possibleRule)) {
                //if found a matching rule, add it's parents to the next empty page corresponding to the cell
                List<String> parents = grammar.getParentsByChild(rule);
                for (int j = 0; j < parents.size(); j++) {
                    String parent = parents.get(j);
                    t[row][column][nextEmpty(t, row, column)] = parent;
                }
            }
        }
        return t;
    }

    /**
     * Checks whether any pages in the table's last filled cell(i,j) includes the starting symbol.
     * the symbol has at least one child but no parents.
     *
     * @param t        the cyk table
     * @param length   length of the array of words
     * @param maxDepth maximum amount of pages per cell
     * @param parents  all symbols in the grammar with at least one child
     * @param children all symbols in the grammar with at least one parent
     * @return true if at least one of the pages includes a starting symbol, false otherwise
     */
    public boolean topRulesIncludeStartingSymbol(String[][][] t, int length, int maxDepth, List<String> parents, List<List<String>> children) {
        String root = grammar.getRoot();

        boolean found = false;

        for (int i = 0; i < maxDepth; i++) {
            if (t[0][length - 1][i] != null) {
                String possibleStartingSymbol = t[0][length - 1][i];

                if (possibleStartingSymbol.equals(root)) {
                    found = true;
                    break;
                }
            }
        }
        return found;
    }

    /**
     * Finds the next empty page of a cell(i,j) in the 3-dimensional table t
     *
     * @param t      the cyk table
     * @param row    row number
     * @param column column number
     * @return the index of the next empty page of cell(i,j)
     */
    public static int nextEmpty(String[][][] t, int row, int column) {
        int maxDepth = t[row][column].length - 1;

        for (int depth = 0; depth < maxDepth; depth++) {
            if (t[row][column][depth] == null) {
                return depth;
            }
        }
        return maxDepth;
    }
}
